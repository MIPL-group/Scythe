Thanks for reviewers' valuable comments to help us clarify unclear facts and improve our presentation of the paper.

We are sorry for the confusions caused by our presentation and we promise that we will work hard to make the paper more clear and easy to read.

Addressing reviewers' comments:

=== Reviewer A:

1. Equivalence between tables:

    The definition of equivalence is based on bag (or multiset) representation: two bags are equivalent iff the have same elements and elements duplicity are the same. Bag semantics is used in a majority of modern databases including Oracle, MySQL, SQL Server etc.

2. It is unclear how can this captures all kinds of query skeletons.

    The burden of generating varies query skeletons is put on the first reduction: when we enumerate skeletons, we only left holes in the projection predicate and filter predicates. This distribution of the burdens enables the second half of the algorithm only to consider learning filter and projection predicates, and the enumeration phase ranges over all different skeletons defined by SynthSQL grammar to ensure completeness (as presented in Figure 9).

3. How can we address the problem with deDup in the property:

    The problem is addressed in the following way (as we shown in line 21 of Figure 13): 

        1) if neither of $proj(filter(coreTable(\row),\oplus \beta),\gamma)$ or $T_{out}$ contains duplicates, then learn filter and projector are immediately correct when the property is hold.

        2) if $proj(filter(coreTable(\row),\oplus \beta),\gamma)$ contains duplicate but not $T_{out}$, then we emit key word "select-distinct" and the filter and projector are correct.

        3) if both of them contain duplicates, then the property is a necessary (but not sufficient) condition for the filter and projector to be correct, and the checking condition in line 21 the algorithm ensures the correctness.

        ******************** short version: The property is a necessary condition used for pruning and we check its actual correctness in line 21 of Figure 13: i.e. we only need to visit all filters and projectors satisfying the property to ensure completeness.

4. Evaluation:
    
    1) Benchmark selection: we do not reject any post as long as it contains input-output tables (based on our search criteria in Section 10).

    2) Unsupported features: in our benchmark search process, top voted posts related to "union all" or "left outer join" are asking for explanations of the features rather than asking PBE questions and thus not included in the benchmark based on our criteria. But I agree that a more thorough search for more benchmark would help better address our limitation.

    3) The Enum algorithm is in fact built atop of the first and second reduction rather than brutal force search, it enumerates over the space of value encoded queries rather than directly on query trees. The cases that only Scythe can solve are mainly queries that using more nested subqueries or input example with larger tables.

    4) ************* (Alvin suggests me to give a quick run of the SQL synthesizer benchmark to see the result.)

5. Additional comments with the tool:

    1) inconsistency of result: the query printed by Scythe is the second last step result (before projection) and we are sorry that the printed result is confusing: the projection arguments are indeed inferred (or we won't be able to generate correct filter clauses) but not printed back in query since we consider its triviality won't matter in demonstrating the result (as the gap between the second step and the final result is only column names). The correctness of the query (except the projection names) are checked against Stack Overflow answers and we are absolutely sure about the fact.

    2) the user interaction is performed by passing the complexity number in the command-line, and users interact by invoking the tool again on new examples. We didn't perform extra works on the interface since techniques on interactive refinement are orthogonal to our synthesis algorithm.

=== Reviewer B:
  
1. Bias against desugaring: 

    This is a nice point, and we agree that showing only one form of the query to an user may not be very comprehensive if the user is more familiar with other operators. But a simple extension will enable us to solve the problem: we can re-sugar generated query to show multiple syntactically different but semantically equivalent forms to the user for better comprehension purpose.

2.  How general the tool is for other (perhaps more expert) tasks:

    ?? ************** (I don't understand if the reviewer is talking about other features in SQL or other domain)

=== Reviewer C:

1. Extension to disjunction, arithmetic and union:
    
    Adding disjunctions will cause an increasing number of bit-vectors to be memoized (i.e. we also store disjunctions of filters as bit-vectors) and we can decompose the output example to learn individually and generate union queries from results of different parts. Based on our current experience, we won't have a big performance burden since we are already able to efficiently handle sub-queries with keyword Exists. However, ranking can be a problem: since adding these two features, particularly disjunction, a large number of consistent but not correct queries will occur and makes it harder to rank effective by heuristic. (Fortunately, most queries in Database literatures and practice are conjunctive queries.)

    Besides, adding arithmetic is strait for us (by extending bit-vector encodings), and we are working on making this extension.

2. Figure cuts off search at 100 seconds:

    This is an extremely good point: we actually performed the experiment with a 10 minute time limit, we chose 100s as a cut-off for the purpose of easy to draw the graph. 

