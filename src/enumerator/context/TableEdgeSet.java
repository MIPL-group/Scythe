package enumerator.context;

import sql.lang.Table;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * The data structure recording the connection between tables in the value (table) net
 * Created by clwang on 4/6/16.
 */
public class TableEdgeSet {

    // storing the edges backwardly, the key represents the destination
    // while the value set contains source nodes that can lead to the table.
    // The source nodes of the edges
    Map<Table, Set<Set<Table>>> edges = new HashMap<>();

    // insert an edge with one source node
    public void insertEdge(Table src, Table dst) {
        // the node contains one table
        Set<Table> node = new HashSet<>();
        node.add(src);
        if (edges.containsKey(dst)) {
            edges.get(dst).add(node);
        } else {
            edges.put(dst, new HashSet<>());
            edges.get(dst).add(node);
        }
    }

    // insert an edge with two leading source nodes
    public void insertEdge(Table src1, Table src2, Table dst) {
        // the node contain two tables
        Set<Table> node = new HashSet<>();
        node.add(src1);
        node.add(src2);

        if (edges.containsKey(dst)) {
            edges.get(dst).add(node);
        } else {
            edges.put(dst, new HashSet<>());
            edges.get(dst).add(node);
        }
    }

    public Map<Table, Set<Set<Table>>> edges() { return this.edges; }

    public int getDirectLinkCount(Table table) {
        return edges.get(table) == null ? 0 : edges.get(table).size();
    }

    public List<TableTreeNode> findTableTrees(Table root, Set<Table> leafNodes, int depth) {
        List<TableTreeNode> result = new ArrayList<>();

        // if the target we want to construct is a leaf node, directly return it.
        if (leafNodes.contains(root)) {
            result.add(new TableTreeNode(root, new ArrayList<>()));
            return result;
        }
        // if we have to terminate now while the current node is not yet a leaf node, we abort the search
        if (depth == 0) { return new ArrayList<>(); }

        for (Set<Table> src : edges.get(root)) {
            List<Table> srcList = new ArrayList<>();
            srcList.addAll(src);
            // each list in the list contains all candidate for the nodes in src
            List<List<TableTreeNode>> subTreeCandidates = horizontalDFS(srcList, leafNodes, depth -1);
            for (List<TableTreeNode> ttL : subTreeCandidates) {
                result.add(new TableTreeNode(root, ttL));
            }
        }

        return result;
    }

    // find a list such that each List in the list a a way to generate all tabletreenodes for the given tables.
    public List<List<TableTreeNode>> horizontalDFS(List<Table> tables, Set<Table> leafNodes, int depth) {
        List<List<TableTreeNode>> result = new ArrayList<>();

        // if the table list to expand is empty, we feed an empty list to keep the search going on
        if (tables.size() == 0) {
            result.add(new ArrayList<>());
            return result;
        }

        // candidates generated by the tails
        List<Table> subTables = tables.subList(1, tables.size());
        List<List<TableTreeNode>> prevCandidates = horizontalDFS(subTables, leafNodes, depth);

        List<TableTreeNode> nodes = findTableTrees(tables.get(0), leafNodes, depth);
        for (TableTreeNode n : nodes) {
            for (List<TableTreeNode> prevCand : prevCandidates) {
                List<TableTreeNode> newCand = new ArrayList<>();
                // append to head
                newCand.add(n);
                newCand.addAll(prevCand);
                result.add(newCand);
            }
        }
        return result;
    }

}
